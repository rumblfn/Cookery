{"ast":null,"code":"// write data to it, and it'll emit data in 512 byte blocks.\n// if you .end() or .flush(), it'll emit whatever it's got,\n// padded with nulls to 512 bytes.\nmodule.exports = BlockStream;\n\nvar Stream = require(\"stream\").Stream,\n    inherits = require(\"inherits\"),\n    assert = require(\"assert\").ok,\n    debug = process.env.DEBUG ? console.error : function () {};\n\nfunction BlockStream(size, opt) {\n  this.writable = this.readable = true;\n  this._opt = opt || {};\n  this._chunkSize = size || 512;\n  this._offset = 0;\n  this._buffer = [];\n  this._bufferLength = 0;\n  if (this._opt.nopad) this._zeroes = false;else {\n    this._zeroes = new Buffer(this._chunkSize);\n\n    for (var i = 0; i < this._chunkSize; i++) {\n      this._zeroes[i] = 0;\n    }\n  }\n}\n\ninherits(BlockStream, Stream);\n\nBlockStream.prototype.write = function (c) {\n  // debug(\"   BS write\", c)\n  if (this._ended) throw new Error(\"BlockStream: write after end\");\n  if (c && !Buffer.isBuffer(c)) c = new Buffer(c + \"\");\n\n  if (c.length) {\n    this._buffer.push(c);\n\n    this._bufferLength += c.length;\n  } // debug(\"pushed onto buffer\", this._bufferLength)\n\n\n  if (this._bufferLength >= this._chunkSize) {\n    if (this._paused) {\n      // debug(\"   BS paused, return false, need drain\")\n      this._needDrain = true;\n      return false;\n    }\n\n    this._emitChunk();\n  }\n\n  return true;\n};\n\nBlockStream.prototype.pause = function () {\n  // debug(\"   BS pausing\")\n  this._paused = true;\n};\n\nBlockStream.prototype.resume = function () {\n  // debug(\"   BS resume\")\n  this._paused = false;\n  return this._emitChunk();\n};\n\nBlockStream.prototype.end = function (chunk) {\n  // debug(\"end\", chunk)\n  if (typeof chunk === \"function\") cb = chunk, chunk = null;\n  if (chunk) this.write(chunk);\n  this._ended = true;\n  this.flush();\n};\n\nBlockStream.prototype.flush = function () {\n  this._emitChunk(true);\n};\n\nBlockStream.prototype._emitChunk = function (flush) {\n  // debug(\"emitChunk flush=%j emitting=%j paused=%j\", flush, this._emitting, this._paused)\n  // emit a <chunkSize> chunk\n  if (flush && this._zeroes) {\n    // debug(\"    BS push zeroes\", this._bufferLength)\n    // push a chunk of zeroes\n    var padBytes = this._bufferLength % this._chunkSize;\n    if (padBytes !== 0) padBytes = this._chunkSize - padBytes;\n\n    if (padBytes > 0) {\n      // debug(\"padBytes\", padBytes, this._zeroes.slice(0, padBytes))\n      this._buffer.push(this._zeroes.slice(0, padBytes));\n\n      this._bufferLength += padBytes; // debug(this._buffer[this._buffer.length - 1].length, this._bufferLength)\n    }\n  }\n\n  if (this._emitting || this._paused) return;\n  this._emitting = true; // debug(\"    BS entering loops\")\n\n  var bufferIndex = 0;\n\n  while (this._bufferLength >= this._chunkSize && (flush || !this._paused)) {\n    // debug(\"     BS data emission loop\", this._bufferLength)\n    var out,\n        outOffset = 0,\n        outHas = this._chunkSize;\n\n    while (outHas > 0 && (flush || !this._paused)) {\n      // debug(\"    BS data inner emit loop\", this._bufferLength)\n      var cur = this._buffer[bufferIndex],\n          curHas = cur.length - this._offset; // debug(\"cur=\", cur)\n      // debug(\"curHas=%j\", curHas)\n      // If it's not big enough to fill the whole thing, then we'll need\n      // to copy multiple buffers into one.  However, if it is big enough,\n      // then just slice out the part we want, to save unnecessary copying.\n      // Also, need to copy if we've already done some copying, since buffers\n      // can't be joined like cons strings.\n\n      if (out || curHas < outHas) {\n        out = out || new Buffer(this._chunkSize);\n        cur.copy(out, outOffset, this._offset, this._offset + Math.min(curHas, outHas));\n      } else if (cur.length === outHas && this._offset === 0) {\n        // shortcut -- cur is exactly long enough, and no offset.\n        out = cur;\n      } else {\n        // slice out the piece of cur that we need.\n        out = cur.slice(this._offset, this._offset + outHas);\n      }\n\n      if (curHas > outHas) {\n        // means that the current buffer couldn't be completely output\n        // update this._offset to reflect how much WAS written\n        this._offset += outHas;\n        outHas = 0;\n      } else {\n        // output the entire current chunk.\n        // toss it away\n        outHas -= curHas;\n        outOffset += curHas;\n        bufferIndex++;\n        this._offset = 0;\n      }\n    }\n\n    this._bufferLength -= this._chunkSize;\n    assert(out.length === this._chunkSize); // debug(\"emitting data\", out)\n    // debug(\"   BS emitting, paused=%j\", this._paused, this._bufferLength)\n\n    this.emit(\"data\", out);\n    out = null;\n  } // debug(\"    BS out of loops\", this._bufferLength)\n  // whatever is left, it's not enough to fill up a block, or we're paused\n\n\n  this._buffer = this._buffer.slice(bufferIndex);\n\n  if (this._paused) {\n    // debug(\"    BS paused, leaving\", this._bufferLength)\n    this._needsDrain = true;\n    this._emitting = false;\n    return;\n  } // if flushing, and not using null-padding, then need to emit the last\n  // chunk(s) sitting in the queue.  We know that it's not enough to\n  // fill up a whole block, because otherwise it would have been emitted\n  // above, but there may be some offset.\n\n\n  var l = this._buffer.length;\n\n  if (flush && !this._zeroes && l) {\n    if (l === 1) {\n      if (this._offset) {\n        this.emit(\"data\", this._buffer[0].slice(this._offset));\n      } else {\n        this.emit(\"data\", this._buffer[0]);\n      }\n    } else {\n      var outHas = this._bufferLength,\n          out = new Buffer(outHas),\n          outOffset = 0;\n\n      for (var i = 0; i < l; i++) {\n        var cur = this._buffer[i],\n            curHas = cur.length - this._offset;\n        cur.copy(out, outOffset, this._offset);\n        this._offset = 0;\n        outOffset += curHas;\n        this._bufferLength -= curHas;\n      }\n\n      this.emit(\"data\", out);\n    } // truncate\n\n\n    this._buffer.length = 0;\n    this._bufferLength = 0;\n    this._offset = 0;\n  } // now either drained or ended\n  // debug(\"either draining, or ended\", this._bufferLength, this._ended)\n  // means that we've flushed out all that we can so far.\n\n\n  if (this._needDrain) {\n    // debug(\"emitting drain\", this._bufferLength)\n    this._needDrain = false;\n    this.emit(\"drain\");\n  }\n\n  if (this._bufferLength === 0 && this._ended && !this._endEmitted) {\n    // debug(\"emitting end\", this._bufferLength)\n    this._endEmitted = true;\n    this.emit(\"end\");\n  }\n\n  this._emitting = false; // debug(\"    BS no longer emitting\", flush, this._paused, this._emitting, this._bufferLength, this._chunkSize)\n};","map":{"version":3,"sources":["/Users/samilvaliahmetov/education/programming/schoolProject/my-app/node_modules/block-stream/block-stream.js"],"names":["module","exports","BlockStream","Stream","require","inherits","assert","ok","debug","process","env","DEBUG","console","error","size","opt","writable","readable","_opt","_chunkSize","_offset","_buffer","_bufferLength","nopad","_zeroes","Buffer","i","prototype","write","c","_ended","Error","isBuffer","length","push","_paused","_needDrain","_emitChunk","pause","resume","end","chunk","cb","flush","padBytes","slice","_emitting","bufferIndex","out","outOffset","outHas","cur","curHas","copy","Math","min","emit","_needsDrain","l","_endEmitted"],"mappings":"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","sourcesContent":["// write data to it, and it'll emit data in 512 byte blocks.\n// if you .end() or .flush(), it'll emit whatever it's got,\n// padded with nulls to 512 bytes.\n\nmodule.exports = BlockStream\n\nvar Stream = require(\"stream\").Stream\n  , inherits = require(\"inherits\")\n  , assert = require(\"assert\").ok\n  , debug = process.env.DEBUG ? console.error : function () {}\n\nfunction BlockStream (size, opt) {\n  this.writable = this.readable = true\n  this._opt = opt || {}\n  this._chunkSize = size || 512\n  this._offset = 0\n  this._buffer = []\n  this._bufferLength = 0\n  if (this._opt.nopad) this._zeroes = false\n  else {\n    this._zeroes = new Buffer(this._chunkSize)\n    for (var i = 0; i < this._chunkSize; i ++) {\n      this._zeroes[i] = 0\n    }\n  }\n}\n\ninherits(BlockStream, Stream)\n\nBlockStream.prototype.write = function (c) {\n  // debug(\"   BS write\", c)\n  if (this._ended) throw new Error(\"BlockStream: write after end\")\n  if (c && !Buffer.isBuffer(c)) c = new Buffer(c + \"\")\n  if (c.length) {\n    this._buffer.push(c)\n    this._bufferLength += c.length\n  }\n  // debug(\"pushed onto buffer\", this._bufferLength)\n  if (this._bufferLength >= this._chunkSize) {\n    if (this._paused) {\n      // debug(\"   BS paused, return false, need drain\")\n      this._needDrain = true\n      return false\n    }\n    this._emitChunk()\n  }\n  return true\n}\n\nBlockStream.prototype.pause = function () {\n  // debug(\"   BS pausing\")\n  this._paused = true\n}\n\nBlockStream.prototype.resume = function () {\n  // debug(\"   BS resume\")\n  this._paused = false\n  return this._emitChunk()\n}\n\nBlockStream.prototype.end = function (chunk) {\n  // debug(\"end\", chunk)\n  if (typeof chunk === \"function\") cb = chunk, chunk = null\n  if (chunk) this.write(chunk)\n  this._ended = true\n  this.flush()\n}\n\nBlockStream.prototype.flush = function () {\n  this._emitChunk(true)\n}\n\nBlockStream.prototype._emitChunk = function (flush) {\n  // debug(\"emitChunk flush=%j emitting=%j paused=%j\", flush, this._emitting, this._paused)\n\n  // emit a <chunkSize> chunk\n  if (flush && this._zeroes) {\n    // debug(\"    BS push zeroes\", this._bufferLength)\n    // push a chunk of zeroes\n    var padBytes = (this._bufferLength % this._chunkSize)\n    if (padBytes !== 0) padBytes = this._chunkSize - padBytes\n    if (padBytes > 0) {\n      // debug(\"padBytes\", padBytes, this._zeroes.slice(0, padBytes))\n      this._buffer.push(this._zeroes.slice(0, padBytes))\n      this._bufferLength += padBytes\n      // debug(this._buffer[this._buffer.length - 1].length, this._bufferLength)\n    }\n  }\n\n  if (this._emitting || this._paused) return\n  this._emitting = true\n\n  // debug(\"    BS entering loops\")\n  var bufferIndex = 0\n  while (this._bufferLength >= this._chunkSize &&\n         (flush || !this._paused)) {\n    // debug(\"     BS data emission loop\", this._bufferLength)\n\n    var out\n      , outOffset = 0\n      , outHas = this._chunkSize\n\n    while (outHas > 0 && (flush || !this._paused) ) {\n      // debug(\"    BS data inner emit loop\", this._bufferLength)\n      var cur = this._buffer[bufferIndex]\n        , curHas = cur.length - this._offset\n      // debug(\"cur=\", cur)\n      // debug(\"curHas=%j\", curHas)\n      // If it's not big enough to fill the whole thing, then we'll need\n      // to copy multiple buffers into one.  However, if it is big enough,\n      // then just slice out the part we want, to save unnecessary copying.\n      // Also, need to copy if we've already done some copying, since buffers\n      // can't be joined like cons strings.\n      if (out || curHas < outHas) {\n        out = out || new Buffer(this._chunkSize)\n        cur.copy(out, outOffset,\n                 this._offset, this._offset + Math.min(curHas, outHas))\n      } else if (cur.length === outHas && this._offset === 0) {\n        // shortcut -- cur is exactly long enough, and no offset.\n        out = cur\n      } else {\n        // slice out the piece of cur that we need.\n        out = cur.slice(this._offset, this._offset + outHas)\n      }\n\n      if (curHas > outHas) {\n        // means that the current buffer couldn't be completely output\n        // update this._offset to reflect how much WAS written\n        this._offset += outHas\n        outHas = 0\n      } else {\n        // output the entire current chunk.\n        // toss it away\n        outHas -= curHas\n        outOffset += curHas\n        bufferIndex ++\n        this._offset = 0\n      }\n    }\n\n    this._bufferLength -= this._chunkSize\n    assert(out.length === this._chunkSize)\n    // debug(\"emitting data\", out)\n    // debug(\"   BS emitting, paused=%j\", this._paused, this._bufferLength)\n    this.emit(\"data\", out)\n    out = null\n  }\n  // debug(\"    BS out of loops\", this._bufferLength)\n\n  // whatever is left, it's not enough to fill up a block, or we're paused\n  this._buffer = this._buffer.slice(bufferIndex)\n  if (this._paused) {\n    // debug(\"    BS paused, leaving\", this._bufferLength)\n    this._needsDrain = true\n    this._emitting = false\n    return\n  }\n\n  // if flushing, and not using null-padding, then need to emit the last\n  // chunk(s) sitting in the queue.  We know that it's not enough to\n  // fill up a whole block, because otherwise it would have been emitted\n  // above, but there may be some offset.\n  var l = this._buffer.length\n  if (flush && !this._zeroes && l) {\n    if (l === 1) {\n      if (this._offset) {\n        this.emit(\"data\", this._buffer[0].slice(this._offset))\n      } else {\n        this.emit(\"data\", this._buffer[0])\n      }\n    } else {\n      var outHas = this._bufferLength\n        , out = new Buffer(outHas)\n        , outOffset = 0\n      for (var i = 0; i < l; i ++) {\n        var cur = this._buffer[i]\n          , curHas = cur.length - this._offset\n        cur.copy(out, outOffset, this._offset)\n        this._offset = 0\n        outOffset += curHas\n        this._bufferLength -= curHas\n      }\n      this.emit(\"data\", out)\n    }\n    // truncate\n    this._buffer.length = 0\n    this._bufferLength = 0\n    this._offset = 0\n  }\n\n  // now either drained or ended\n  // debug(\"either draining, or ended\", this._bufferLength, this._ended)\n  // means that we've flushed out all that we can so far.\n  if (this._needDrain) {\n    // debug(\"emitting drain\", this._bufferLength)\n    this._needDrain = false\n    this.emit(\"drain\")\n  }\n\n  if ((this._bufferLength === 0) && this._ended && !this._endEmitted) {\n    // debug(\"emitting end\", this._bufferLength)\n    this._endEmitted = true\n    this.emit(\"end\")\n  }\n\n  this._emitting = false\n\n  // debug(\"    BS no longer emitting\", flush, this._paused, this._emitting, this._bufferLength, this._chunkSize)\n}\n"]},"metadata":{},"sourceType":"script"}