{"ast":null,"code":"module.exports = ExtendedHeaderWriter;\n\nvar inherits = require(\"inherits\"),\n    EntryWriter = require(\"./entry-writer.js\");\n\ninherits(ExtendedHeaderWriter, EntryWriter);\n\nvar tar = require(\"../tar.js\"),\n    path = require(\"path\"),\n    TarHeader = require(\"./header.js\"); // props is the props of the thing we need to write an\n// extended header for.\n// Don't be shy with it.  Just encode everything.\n\n\nfunction ExtendedHeaderWriter(props) {\n  // console.error(\">> ehw ctor\")\n  var me = this;\n\n  if (!(me instanceof ExtendedHeaderWriter)) {\n    return new ExtendedHeaderWriter(props);\n  }\n\n  me.fields = props;\n  var p = {\n    path: (\"PaxHeader\" + path.join(\"/\", props.path || \"\")).replace(/\\\\/g, \"/\").substr(0, 100),\n    mode: props.mode || 0666,\n    uid: props.uid || 0,\n    gid: props.gid || 0,\n    size: 0 // will be set later\n    ,\n    mtime: props.mtime || Date.now() / 1000,\n    type: \"x\",\n    linkpath: \"\",\n    ustar: \"ustar\\0\",\n    ustarver: \"00\",\n    uname: props.uname || \"\",\n    gname: props.gname || \"\",\n    devmaj: props.devmaj || 0,\n    devmin: props.devmin || 0\n  };\n  EntryWriter.call(me, p); // console.error(\">> ehw props\", me.props)\n\n  me.props = p;\n  me._meta = true;\n}\n\nExtendedHeaderWriter.prototype.end = function () {\n  // console.error(\">> ehw end\")\n  var me = this;\n  if (me._ended) return;\n  me._ended = true;\n\n  me._encodeFields();\n\n  if (me.props.size === 0) {\n    // nothing to write!\n    me._ready = true;\n\n    me._stream.end();\n\n    return;\n  }\n\n  me._stream.write(TarHeader.encode(me.props));\n\n  me.body.forEach(function (l) {\n    me._stream.write(l);\n  });\n  me._ready = true; // console.error(\">> ehw _process calling end()\", me.props)\n\n  this._stream.end();\n};\n\nExtendedHeaderWriter.prototype._encodeFields = function () {\n  // console.error(\">> ehw _encodeFields\")\n  this.body = [];\n\n  if (this.fields.prefix) {\n    this.fields.path = this.fields.prefix + \"/\" + this.fields.path;\n    this.fields.prefix = \"\";\n  }\n\n  encodeFields(this.fields, \"\", this.body, this.fields.noProprietary);\n  var me = this;\n  this.body.forEach(function (l) {\n    me.props.size += l.length;\n  });\n};\n\nfunction encodeFields(fields, prefix, body, nop) {\n  // console.error(\">> >> ehw encodeFields\")\n  // \"%d %s=%s\\n\", <length>, <keyword>, <value>\n  // The length is a decimal number, and includes itself and the \\n\n  // Numeric values are decimal strings.\n  Object.keys(fields).forEach(function (k) {\n    var val = fields[k],\n        numeric = tar.numeric[k];\n    if (prefix) k = prefix + \".\" + k; // already including NODETAR.type, don't need File=true also\n\n    if (k === fields.type && val === true) return;\n\n    switch (k) {\n      // don't include anything that's always handled just fine\n      // in the normal header, or only meaningful in the context\n      // of nodetar\n      case \"mode\":\n      case \"cksum\":\n      case \"ustar\":\n      case \"ustarver\":\n      case \"prefix\":\n      case \"basename\":\n      case \"dirname\":\n      case \"needExtended\":\n      case \"block\":\n      case \"filter\":\n        return;\n\n      case \"rdev\":\n        if (val === 0) return;\n        break;\n\n      case \"nlink\":\n      case \"dev\": // Truly a hero among men, Creator of Star!\n\n      case \"ino\":\n        // Speak his name with reverent awe!  It is:\n        k = \"SCHILY.\" + k;\n        break;\n\n      default:\n        break;\n    }\n\n    if (val && typeof val === \"object\" && !Buffer.isBuffer(val)) encodeFields(val, k, body, nop);else if (val === null || val === undefined) return;else body.push.apply(body, encodeField(k, val, nop));\n  });\n  return body;\n}\n\nfunction encodeField(k, v, nop) {\n  // lowercase keys must be valid, otherwise prefix with\n  // \"NODETAR.\"\n  if (k.charAt(0) === k.charAt(0).toLowerCase()) {\n    var m = k.split(\".\")[0];\n    if (!tar.knownExtended[m]) k = \"NODETAR.\" + k;\n  } // no proprietary\n\n\n  if (nop && k.charAt(0) !== k.charAt(0).toLowerCase()) {\n    return [];\n  }\n\n  if (typeof val === \"number\") val = val.toString(10);\n  var s = new Buffer(\" \" + k + \"=\" + v + \"\\n\"),\n      digits = Math.floor(Math.log(s.length) / Math.log(10)) + 1; // console.error(\"1 s=%j digits=%j s.length=%d\", s.toString(), digits, s.length)\n  // if adding that many digits will make it go over that length,\n  // then add one to it. For example, if the string is:\n  // \" foo=bar\\n\"\n  // then that's 9 characters.  With the \"9\", that bumps the length\n  // up to 10.  However, this is invalid:\n  // \"10 foo=bar\\n\"\n  // but, since that's actually 11 characters, since 10 adds another\n  // character to the length, and the length includes the number\n  // itself.  In that case, just bump it up again.\n\n  if (s.length + digits >= Math.pow(10, digits)) digits += 1; // console.error(\"2 s=%j digits=%j s.length=%d\", s.toString(), digits, s.length)\n\n  var len = digits + s.length; // console.error(\"3 s=%j digits=%j s.length=%d len=%d\", s.toString(), digits, s.length, len)\n\n  var lenBuf = new Buffer(\"\" + len);\n\n  if (lenBuf.length + s.length !== len) {\n    throw new Error(\"Bad length calculation\\n\" + \"len=\" + len + \"\\n\" + \"lenBuf=\" + JSON.stringify(lenBuf.toString()) + \"\\n\" + \"lenBuf.length=\" + lenBuf.length + \"\\n\" + \"digits=\" + digits + \"\\n\" + \"s=\" + JSON.stringify(s.toString()) + \"\\n\" + \"s.length=\" + s.length);\n  }\n\n  return [lenBuf, s];\n}","map":{"version":3,"sources":["/Users/samilvaliahmetov/education/programming/schoolProject/my-app/node_modules/node-gyp/node_modules/tar/lib/extended-header-writer.js"],"names":["module","exports","ExtendedHeaderWriter","inherits","require","EntryWriter","tar","path","TarHeader","props","me","fields","p","join","replace","substr","mode","uid","gid","size","mtime","Date","now","type","linkpath","ustar","ustarver","uname","gname","devmaj","devmin","call","_meta","prototype","end","_ended","_encodeFields","_ready","_stream","write","encode","body","forEach","l","prefix","encodeFields","noProprietary","length","nop","Object","keys","k","val","numeric","Buffer","isBuffer","undefined","push","apply","encodeField","v","charAt","toLowerCase","m","split","knownExtended","toString","s","digits","Math","floor","log","pow","len","lenBuf","Error","JSON","stringify"],"mappings":"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","sourcesContent":["\nmodule.exports = ExtendedHeaderWriter\n\nvar inherits = require(\"inherits\")\n  , EntryWriter = require(\"./entry-writer.js\")\n\ninherits(ExtendedHeaderWriter, EntryWriter)\n\nvar tar = require(\"../tar.js\")\n  , path = require(\"path\")\n  , TarHeader = require(\"./header.js\")\n\n// props is the props of the thing we need to write an\n// extended header for.\n// Don't be shy with it.  Just encode everything.\nfunction ExtendedHeaderWriter (props) {\n  // console.error(\">> ehw ctor\")\n  var me = this\n\n  if (!(me instanceof ExtendedHeaderWriter)) {\n    return new ExtendedHeaderWriter(props)\n  }\n\n  me.fields = props\n\n  var p =\n    { path : (\"PaxHeader\" + path.join(\"/\", props.path || \"\"))\n             .replace(/\\\\/g, \"/\").substr(0, 100)\n    , mode : props.mode || 0666\n    , uid : props.uid || 0\n    , gid : props.gid || 0\n    , size : 0 // will be set later\n    , mtime : props.mtime || Date.now() / 1000\n    , type : \"x\"\n    , linkpath : \"\"\n    , ustar : \"ustar\\0\"\n    , ustarver : \"00\"\n    , uname : props.uname || \"\"\n    , gname : props.gname || \"\"\n    , devmaj : props.devmaj || 0\n    , devmin : props.devmin || 0\n    }\n\n\n  EntryWriter.call(me, p)\n  // console.error(\">> ehw props\", me.props)\n  me.props = p\n\n  me._meta = true\n}\n\nExtendedHeaderWriter.prototype.end = function () {\n  // console.error(\">> ehw end\")\n  var me = this\n\n  if (me._ended) return\n  me._ended = true\n\n  me._encodeFields()\n\n  if (me.props.size === 0) {\n    // nothing to write!\n    me._ready = true\n    me._stream.end()\n    return\n  }\n\n  me._stream.write(TarHeader.encode(me.props))\n  me.body.forEach(function (l) {\n    me._stream.write(l)\n  })\n  me._ready = true\n\n  // console.error(\">> ehw _process calling end()\", me.props)\n  this._stream.end()\n}\n\nExtendedHeaderWriter.prototype._encodeFields = function () {\n  // console.error(\">> ehw _encodeFields\")\n  this.body = []\n  if (this.fields.prefix) {\n    this.fields.path = this.fields.prefix + \"/\" + this.fields.path\n    this.fields.prefix = \"\"\n  }\n  encodeFields(this.fields, \"\", this.body, this.fields.noProprietary)\n  var me = this\n  this.body.forEach(function (l) {\n    me.props.size += l.length\n  })\n}\n\nfunction encodeFields (fields, prefix, body, nop) {\n  // console.error(\">> >> ehw encodeFields\")\n  // \"%d %s=%s\\n\", <length>, <keyword>, <value>\n  // The length is a decimal number, and includes itself and the \\n\n  // Numeric values are decimal strings.\n\n  Object.keys(fields).forEach(function (k) {\n    var val = fields[k]\n      , numeric = tar.numeric[k]\n\n    if (prefix) k = prefix + \".\" + k\n\n    // already including NODETAR.type, don't need File=true also\n    if (k === fields.type && val === true) return\n\n    switch (k) {\n      // don't include anything that's always handled just fine\n      // in the normal header, or only meaningful in the context\n      // of nodetar\n      case \"mode\":\n      case \"cksum\":\n      case \"ustar\":\n      case \"ustarver\":\n      case \"prefix\":\n      case \"basename\":\n      case \"dirname\":\n      case \"needExtended\":\n      case \"block\":\n      case \"filter\":\n        return\n\n      case \"rdev\":\n        if (val === 0) return\n        break\n\n      case \"nlink\":\n      case \"dev\": // Truly a hero among men, Creator of Star!\n      case \"ino\": // Speak his name with reverent awe!  It is:\n        k = \"SCHILY.\" + k\n        break\n\n      default: break\n    }\n\n    if (val && typeof val === \"object\" &&\n        !Buffer.isBuffer(val)) encodeFields(val, k, body, nop)\n    else if (val === null || val === undefined) return\n    else body.push.apply(body, encodeField(k, val, nop))\n  })\n\n  return body\n}\n\nfunction encodeField (k, v, nop) {\n  // lowercase keys must be valid, otherwise prefix with\n  // \"NODETAR.\"\n  if (k.charAt(0) === k.charAt(0).toLowerCase()) {\n    var m = k.split(\".\")[0]\n    if (!tar.knownExtended[m]) k = \"NODETAR.\" + k\n  }\n\n  // no proprietary\n  if (nop && k.charAt(0) !== k.charAt(0).toLowerCase()) {\n    return []\n  }\n\n  if (typeof val === \"number\") val = val.toString(10)\n\n  var s = new Buffer(\" \" + k + \"=\" + v + \"\\n\")\n    , digits = Math.floor(Math.log(s.length) / Math.log(10)) + 1\n\n  // console.error(\"1 s=%j digits=%j s.length=%d\", s.toString(), digits, s.length)\n\n  // if adding that many digits will make it go over that length,\n  // then add one to it. For example, if the string is:\n  // \" foo=bar\\n\"\n  // then that's 9 characters.  With the \"9\", that bumps the length\n  // up to 10.  However, this is invalid:\n  // \"10 foo=bar\\n\"\n  // but, since that's actually 11 characters, since 10 adds another\n  // character to the length, and the length includes the number\n  // itself.  In that case, just bump it up again.\n  if (s.length + digits >= Math.pow(10, digits)) digits += 1\n  // console.error(\"2 s=%j digits=%j s.length=%d\", s.toString(), digits, s.length)\n\n  var len = digits + s.length\n  // console.error(\"3 s=%j digits=%j s.length=%d len=%d\", s.toString(), digits, s.length, len)\n  var lenBuf = new Buffer(\"\" + len)\n  if (lenBuf.length + s.length !== len) {\n    throw new Error(\"Bad length calculation\\n\"+\n                    \"len=\"+len+\"\\n\"+\n                    \"lenBuf=\"+JSON.stringify(lenBuf.toString())+\"\\n\"+\n                    \"lenBuf.length=\"+lenBuf.length+\"\\n\"+\n                    \"digits=\"+digits+\"\\n\"+\n                    \"s=\"+JSON.stringify(s.toString())+\"\\n\"+\n                    \"s.length=\"+s.length)\n  }\n\n  return [lenBuf, s]\n}\n"]},"metadata":{},"sourceType":"script"}