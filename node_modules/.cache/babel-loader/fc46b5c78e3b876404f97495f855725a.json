{"ast":null,"code":"module.exports = exports = function (gyp, argv, callback) {\n  return install(fs, gyp, argv, callback);\n};\n\nmodule.exports.test = {\n  download: download,\n  install: install,\n  readCAFile: readCAFile\n};\nexports.usage = 'Install node development files for the specified node version.';\n/**\n * Module dependencies.\n */\n\nvar fs = require('graceful-fs'),\n    osenv = require('osenv'),\n    tar = require('tar'),\n    rm = require('rimraf'),\n    path = require('path'),\n    crypto = require('crypto'),\n    zlib = require('zlib'),\n    log = require('npmlog'),\n    semver = require('semver'),\n    fstream = require('fstream'),\n    request = require('request'),\n    mkdir = require('mkdirp'),\n    processRelease = require('./process-release'),\n    win = process.platform == 'win32';\n\nfunction install(fs, gyp, argv, callback) {\n  var release = processRelease(argv, gyp, process.version, process.release); // ensure no double-callbacks happen\n\n  function cb(err) {\n    if (cb.done) return;\n    cb.done = true;\n\n    if (err) {\n      log.warn('install', 'got an error, rolling back install'); // roll-back the install if anything went wrong\n\n      gyp.commands.remove([release.versionDir], function (err2) {\n        callback(err);\n      });\n    } else {\n      callback(null, release.version);\n    }\n  } // Determine which node dev files version we are installing\n\n\n  log.verbose('install', 'input version string %j', release.version);\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version));\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version));\n  } // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n\n\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version);\n\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      callback();\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'));\n    }\n\n    return;\n  } // flatten version into String\n\n\n  log.verbose('install', 'installing version: %s', release.versionDir); // the directory where the dev files will be installed\n\n  var devDir = path.resolve(gyp.devDir, release.versionDir); // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n    fs.stat(devDir, function (err, stat) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n          go();\n        } else if (err.code == 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n\n        return;\n      }\n\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      var installVersionFile = path.resolve(devDir, 'installVersion');\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code != 'ENOENT') {\n          return cb(err);\n        }\n\n        var installVersion = parseInt(ver, 10) || 0;\n        log.verbose('got \"installVersion\"', installVersion);\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling');\n          go();\n        } else {\n          log.verbose('install', 'version is good');\n          cb();\n        }\n      });\n    });\n  } else {\n    go();\n  }\n\n  function getContentSha(res, callback) {\n    var shasum = crypto.createHash('sha256');\n    res.on('data', function (chunk) {\n      shasum.update(chunk);\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'));\n    });\n  }\n\n  function go() {\n    log.verbose('ensuring nodedir is created', devDir); // first create the dir for the node dev files\n\n    mkdir(devDir, function (err, created) {\n      if (err) {\n        if (err.code == 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n\n        return;\n      }\n\n      if (created) {\n        log.verbose('created nodedir', created);\n      } // now download the node tarball\n\n\n      var tarPath = gyp.opts.tarball;\n      var badDownload = false,\n          extractCount = 0,\n          gunzip = zlib.createGunzip(),\n          extracter = tar.Extract({\n        path: devDir,\n        strip: 1,\n        filter: isValid\n      });\n      var contentShasums = {};\n      var expectShasums = {}; // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n\n      function isValid() {\n        var name = this.path.substring(devDir.length + 1);\n        var isValid = valid(name);\n\n        if (name === '' && this.type === 'Directory') {\n          // the first directory entry is ok\n          return true;\n        }\n\n        if (isValid) {\n          log.verbose('extracted file from tarball', name);\n          extractCount++;\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', name);\n        }\n\n        return isValid;\n      }\n\n      gunzip.on('error', cb);\n      extracter.on('error', cb);\n      extracter.on('end', afterTarball); // download the tarball, gunzip and extract!\n\n      if (tarPath) {\n        var input = fs.createReadStream(tarPath);\n        input.pipe(gunzip).pipe(extracter);\n        return;\n      }\n\n      try {\n        var req = download(gyp, process.env, release.tarballUrl);\n      } catch (e) {\n        return cb(e);\n      } // something went wrong downloading the tarball?\n\n\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.'));\n        }\n\n        badDownload = true;\n        cb(err);\n      });\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'));\n        }\n      });\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true;\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl));\n          return;\n        } // content checksum\n\n\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim();\n          contentShasums[filename] = checksum;\n          log.verbose('content checksum', filename, checksum);\n        }); // start unzipping and untaring\n\n        req.pipe(gunzip).pipe(extracter);\n      }); // invoked after the tarball has finished being extracted\n\n      function afterTarball() {\n        if (badDownload) return;\n\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'));\n        }\n\n        log.verbose('tarball', 'done parsing tarball');\n        var async = 0;\n\n        if (win) {\n          // need to download node.lib\n          async++;\n          downloadNodeLib(deref);\n        } // write the \"installVersion\" file\n\n\n        async++;\n        var installVersionPath = path.resolve(devDir, 'installVersion');\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref); // Only download SHASUMS.txt if not using tarPath override\n\n        if (!tarPath) {\n          // download SHASUMS.txt\n          async++;\n          downloadShasums(deref);\n        }\n\n        if (async === 0) {\n          // no async tasks required\n          cb();\n        }\n\n        function deref(err) {\n          if (err) return cb(err);\n          async--;\n\n          if (!async) {\n            log.verbose('download contents checksum', JSON.stringify(contentShasums)); // check content shasums\n\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]));\n                return;\n              }\n            }\n\n            cb();\n          }\n        }\n      }\n\n      function downloadShasums(done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n        var shasumsPath = path.resolve(devDir, 'SHASUMS256.txt');\n        log.verbose('checksum url', release.shasumsUrl);\n\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl);\n        } catch (e) {\n          return cb(e);\n        }\n\n        req.on('error', done);\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'));\n            return;\n          }\n\n          var chunks = [];\n          res.on('data', function (chunk) {\n            chunks.push(chunk);\n          });\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n');\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/);\n              if (items.length !== 2) return; // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n\n              var name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            });\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n            done();\n          });\n        });\n      }\n\n      function downloadNodeLib(done) {\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n        var dir32 = path.resolve(devDir, 'ia32'),\n            dir64 = path.resolve(devDir, 'x64'),\n            libPath32 = path.resolve(dir32, release.name + '.lib'),\n            libPath64 = path.resolve(dir64, release.name + '.lib');\n        log.verbose('32-bit ' + release.name + '.lib dir', dir32);\n        log.verbose('64-bit ' + release.name + '.lib dir', dir64);\n        log.verbose('`' + release.name + '.lib` 32-bit url', release.libUrl32);\n        log.verbose('`' + release.name + '.lib` 64-bit url', release.libUrl64);\n        var async = 2;\n        mkdir(dir32, function (err) {\n          if (err) return done(err);\n          log.verbose('streaming 32-bit ' + release.name + '.lib to:', libPath32);\n\n          try {\n            var req = download(gyp, process.env, release.libUrl32, cb);\n          } catch (e) {\n            return cb(e);\n          }\n\n          req.on('error', done);\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 32-bit ' + release.name + '.lib'));\n              return;\n            }\n\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath32] = checksum;\n              log.verbose('content checksum', release.libPath32, checksum);\n            });\n            var ws = fs.createWriteStream(libPath32);\n            ws.on('error', cb);\n            req.pipe(ws);\n          });\n          req.on('end', function () {\n            --async || done();\n          });\n        });\n        mkdir(dir64, function (err) {\n          if (err) return done(err);\n          log.verbose('streaming 64-bit ' + release.name + '.lib to:', libPath64);\n\n          try {\n            var req = download(gyp, process.env, release.libUrl64, cb);\n          } catch (e) {\n            return cb(e);\n          }\n\n          req.on('error', done);\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 64-bit ' + release.name + '.lib'));\n              return;\n            }\n\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath64] = checksum;\n              log.verbose('content checksum', release.libPath64, checksum);\n            });\n            var ws = fs.createWriteStream(libPath64);\n            ws.on('error', cb);\n            req.pipe(ws);\n          });\n          req.on('end', function () {\n            --async || done();\n          });\n        });\n      } // downloadNodeLib()\n\n    }); // mkdir()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n\n  function valid(file) {\n    // header files\n    var extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n\n  function eaccesFallback(err) {\n    var noretry = '--node_gyp_internal_noretry';\n    if (-1 !== argv.indexOf(noretry)) return cb(err);\n    var tmpdir = osenv.tmpdir();\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n    log.warn('EACCES', 'user \"%s\" does not have permission to access the dev dir \"%s\"', osenv.user(), devDir);\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n\n    if (process.cwd() == tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n      gyp.todo.push({\n        name: 'remove',\n        args: argv\n      });\n    }\n\n    gyp.commands.install([noretry].concat(argv), cb);\n  }\n}\n\nfunction download(gyp, env, url) {\n  log.http('GET', url);\n  var requestOpts = {\n    uri: url,\n    headers: {\n      'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')'\n    }\n  };\n  var cafile = gyp.opts.cafile;\n\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile);\n  } // basic support for a proxy server\n\n\n  var proxyUrl = gyp.opts.proxy || env.http_proxy || env.HTTP_PROXY || env.npm_config_proxy;\n\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl);\n      requestOpts.proxy = proxyUrl;\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n    }\n  }\n\n  var req = request(requestOpts);\n  req.on('response', function (res) {\n    log.http(res.statusCode, url);\n  });\n  return req;\n}\n\nfunction readCAFile(filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8');\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n  return ca.match(re);\n}","map":{"version":3,"sources":["/Users/samilvaliahmetov/education/programming/schoolProject/my-app/node_modules/node-gyp/lib/install.js"],"names":["module","exports","gyp","argv","callback","install","fs","test","download","readCAFile","usage","require","osenv","tar","rm","path","crypto","zlib","log","semver","fstream","request","mkdir","processRelease","win","process","platform","release","version","cb","err","done","warn","commands","remove","versionDir","err2","verbose","Error","lt","prerelease","opts","nodedir","devDir","resolve","ensure","stat","code","go","eaccesFallback","installVersionFile","readFile","ver","installVersion","parseInt","package","getContentSha","res","shasum","createHash","on","chunk","update","digest","created","tarPath","tarball","badDownload","extractCount","gunzip","createGunzip","extracter","Extract","strip","filter","isValid","contentShasums","expectShasums","name","substring","length","valid","type","silly","afterTarball","input","createReadStream","pipe","req","env","tarballUrl","e","statusCode","_","checksum","filename","basename","trim","async","downloadNodeLib","deref","installVersionPath","writeFile","downloadShasums","JSON","stringify","k","shasumsPath","shasumsUrl","chunks","push","lines","Buffer","concat","toString","split","forEach","line","items","replace","dir32","dir64","libPath32","libPath64","libUrl32","libUrl64","ws","createWriteStream","file","extname","noretry","indexOf","tmpdir","user","cwd","todo","args","url","http","requestOpts","uri","headers","cafile","ca","proxyUrl","proxy","http_proxy","HTTP_PROXY","npm_config_proxy","readFileSync","re","match"],"mappings":"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","sourcesContent":["module.exports = exports = function (gyp, argv, callback) {\n  return install(fs, gyp, argv, callback)\n}\n\nmodule.exports.test = {\n  download: download,\n  install: install,\n  readCAFile: readCAFile,\n}\n\nexports.usage = 'Install node development files for the specified node version.'\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('graceful-fs')\n  , osenv = require('osenv')\n  , tar = require('tar')\n  , rm = require('rimraf')\n  , path = require('path')\n  , crypto = require('crypto')\n  , zlib = require('zlib')\n  , log = require('npmlog')\n  , semver = require('semver')\n  , fstream = require('fstream')\n  , request = require('request')\n  , mkdir = require('mkdirp')\n  , processRelease = require('./process-release')\n  , win = process.platform == 'win32'\n\nfunction install (fs, gyp, argv, callback) {\n\n  var release = processRelease(argv, gyp, process.version, process.release)\n\n  // ensure no double-callbacks happen\n  function cb (err) {\n    if (cb.done) return\n    cb.done = true\n    if (err) {\n      log.warn('install', 'got an error, rolling back install')\n      // roll-back the install if anything went wrong\n      gyp.commands.remove([ release.versionDir ], function (err2) {\n        callback(err)\n      })\n    } else {\n      callback(null, release.version)\n    }\n  }\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version))\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version))\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n      callback()\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'))\n    }\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  var devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    fs.stat(devDir, function (err, stat) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version)\n          go()\n        } else if (err.code == 'EACCES') {\n          eaccesFallback(err)\n        } else {\n          cb(err)\n        }\n        return\n      }\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n      var installVersionFile = path.resolve(devDir, 'installVersion')\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code != 'ENOENT') {\n          return cb(err)\n        }\n        var installVersion = parseInt(ver, 10) || 0\n        log.verbose('got \"installVersion\"', installVersion)\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling')\n          go()\n        } else {\n          log.verbose('install', 'version is good')\n          cb()\n        }\n      })\n    })\n  } else {\n    go()\n  }\n\n  function getContentSha(res, callback) {\n    var shasum = crypto.createHash('sha256')\n    res.on('data', function (chunk) {\n      shasum.update(chunk)\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'))\n    })\n  }\n\n  function go () {\n\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    mkdir(devDir, function (err, created) {\n      if (err) {\n        if (err.code == 'EACCES') {\n          eaccesFallback(err)\n        } else {\n          cb(err)\n        }\n        return\n      }\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n\n      // now download the node tarball\n      var tarPath = gyp.opts.tarball\n      var badDownload = false\n        , extractCount = 0\n        , gunzip = zlib.createGunzip()\n        , extracter = tar.Extract({ path: devDir, strip: 1, filter: isValid })\n\n      var contentShasums = {}\n      var expectShasums = {}\n\n      // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n      function isValid () {\n        var name = this.path.substring(devDir.length + 1)\n        var isValid = valid(name)\n        if (name === '' && this.type === 'Directory') {\n          // the first directory entry is ok\n          return true\n        }\n        if (isValid) {\n          log.verbose('extracted file from tarball', name)\n          extractCount++\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', name)\n        }\n        return isValid\n      }\n\n      gunzip.on('error', cb)\n      extracter.on('error', cb)\n      extracter.on('end', afterTarball)\n\n      // download the tarball, gunzip and extract!\n\n      if (tarPath) {\n        var input = fs.createReadStream(tarPath)\n        input.pipe(gunzip).pipe(extracter)\n        return\n      }\n\n      try {\n        var req = download(gyp, process.env, release.tarballUrl)\n      } catch (e) {\n        return cb(e)\n      }\n\n      // something went wrong downloading the tarball?\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.'))\n        }\n        badDownload = true\n        cb(err)\n      })\n\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'))\n        }\n      })\n\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl))\n          return\n        }\n        // content checksum\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim()\n          contentShasums[filename] = checksum\n          log.verbose('content checksum', filename, checksum)\n        })\n\n        // start unzipping and untaring\n        req.pipe(gunzip).pipe(extracter)\n      })\n\n      // invoked after the tarball has finished being extracted\n      function afterTarball () {\n        if (badDownload) return\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'))\n        }\n        log.verbose('tarball', 'done parsing tarball')\n        var async = 0\n\n        if (win) {\n          // need to download node.lib\n          async++\n          downloadNodeLib(deref)\n        }\n\n        // write the \"installVersion\" file\n        async++\n        var installVersionPath = path.resolve(devDir, 'installVersion')\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref)\n\n        // Only download SHASUMS.txt if not using tarPath override\n        if (!tarPath) {\n          // download SHASUMS.txt\n          async++\n          downloadShasums(deref)\n        }\n\n        if (async === 0) {\n          // no async tasks required\n          cb()\n        }\n\n        function deref (err) {\n          if (err) return cb(err)\n\n          async--\n          if (!async) {\n            log.verbose('download contents checksum', JSON.stringify(contentShasums))\n            // check content shasums\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]))\n                return\n              }\n            }\n            cb()\n          }\n        }\n      }\n\n      function downloadShasums(done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n        var shasumsPath = path.resolve(devDir, 'SHASUMS256.txt')\n\n        log.verbose('checksum url', release.shasumsUrl)\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl)\n        } catch (e) {\n          return cb(e)\n        }\n\n        req.on('error', done)\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'))\n            return\n          }\n\n          var chunks = []\n          res.on('data', function (chunk) {\n            chunks.push(chunk)\n          })\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n')\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/)\n              if (items.length !== 2) return\n\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n              var name = items[1].replace(/^\\.\\//, '')\n              expectShasums[name] = items[0]\n            })\n\n            log.verbose('checksum data', JSON.stringify(expectShasums))\n            done()\n          })\n        })\n      }\n\n      function downloadNodeLib (done) {\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n        var dir32 = path.resolve(devDir, 'ia32')\n          , dir64 = path.resolve(devDir, 'x64')\n          , libPath32 = path.resolve(dir32, release.name + '.lib')\n          , libPath64 = path.resolve(dir64, release.name + '.lib')\n\n        log.verbose('32-bit ' + release.name + '.lib dir', dir32)\n        log.verbose('64-bit ' + release.name + '.lib dir', dir64)\n        log.verbose('`' + release.name + '.lib` 32-bit url', release.libUrl32)\n        log.verbose('`' + release.name + '.lib` 64-bit url', release.libUrl64)\n\n        var async = 2\n        mkdir(dir32, function (err) {\n          if (err) return done(err)\n          log.verbose('streaming 32-bit ' + release.name + '.lib to:', libPath32)\n\n          try {\n            var req = download(gyp, process.env, release.libUrl32, cb)\n          } catch (e) {\n            return cb(e)\n          }\n\n          req.on('error', done)\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 32-bit ' + release.name + '.lib'))\n              return\n            }\n\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath32] = checksum\n              log.verbose('content checksum', release.libPath32, checksum)\n            })\n\n            var ws = fs.createWriteStream(libPath32)\n            ws.on('error', cb)\n            req.pipe(ws)\n          })\n          req.on('end', function () {\n            --async || done()\n          })\n        })\n        mkdir(dir64, function (err) {\n          if (err) return done(err)\n          log.verbose('streaming 64-bit ' + release.name + '.lib to:', libPath64)\n\n          try {\n            var req = download(gyp, process.env, release.libUrl64, cb)\n          } catch (e) {\n            return cb(e)\n          }\n\n          req.on('error', done)\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 64-bit ' + release.name + '.lib'))\n              return\n            }\n\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath64] = checksum\n              log.verbose('content checksum', release.libPath64, checksum)\n            })\n\n            var ws = fs.createWriteStream(libPath64)\n            ws.on('error', cb)\n            req.pipe(ws)\n          })\n          req.on('end', function () {\n            --async || done()\n          })\n        })\n      } // downloadNodeLib()\n\n    }) // mkdir()\n\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    var extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  function eaccesFallback (err) {\n    var noretry = '--node_gyp_internal_noretry'\n    if (-1 !== argv.indexOf(noretry)) return cb(err)\n    var tmpdir = osenv.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    log.warn('EACCES', 'user \"%s\" does not have permission to access the dev dir \"%s\"', osenv.user(), devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() == tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    gyp.commands.install([noretry].concat(argv), cb)\n  }\n\n}\n\nfunction download (gyp, env, url) {\n  log.http('GET', url)\n\n  var requestOpts = {\n      uri: url\n    , headers: {\n        'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')'\n      }\n  }\n\n  var cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile)\n  }\n\n  // basic support for a proxy server\n  var proxyUrl = gyp.opts.proxy\n              || env.http_proxy\n              || env.HTTP_PROXY\n              || env.npm_config_proxy\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl)\n      requestOpts.proxy = proxyUrl\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl)\n    }\n  }\n\n  var req = request(requestOpts)\n  req.on('response', function (res) {\n    log.http(res.statusCode, url)\n  })\n\n  return req\n}\n\nfunction readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8')\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n"]},"metadata":{},"sourceType":"script"}