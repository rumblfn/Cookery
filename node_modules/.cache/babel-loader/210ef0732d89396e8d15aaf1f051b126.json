{"ast":null,"code":"// A writable stream.\n// It emits \"entry\" events, which provide a readable stream that has\n// header info attached.\nmodule.exports = Parse.create = Parse;\n\nvar stream = require(\"stream\"),\n    Stream = stream.Stream,\n    BlockStream = require(\"block-stream\"),\n    tar = require(\"../tar.js\"),\n    TarHeader = require(\"./header.js\"),\n    Entry = require(\"./entry.js\"),\n    BufferEntry = require(\"./buffer-entry.js\"),\n    ExtendedHeader = require(\"./extended-header.js\"),\n    assert = require(\"assert\").ok,\n    inherits = require(\"inherits\"),\n    fstream = require(\"fstream\"); // reading a tar is a lot like reading a directory\n// However, we're actually not going to run the ctor,\n// since it does a stat and various other stuff.\n// This inheritance gives us the pause/resume/pipe\n// behavior that is desired.\n\n\ninherits(Parse, fstream.Reader);\n\nfunction Parse() {\n  var me = this;\n  if (!(me instanceof Parse)) return new Parse(); // doesn't apply fstream.Reader ctor?\n  // no, becasue we don't want to stat/etc, we just\n  // want to get the entry/add logic from .pipe()\n\n  Stream.apply(me);\n  me.writable = true;\n  me.readable = true;\n  me._stream = new BlockStream(512);\n  me.position = 0;\n  me._ended = false;\n  me._hardLinks = {};\n\n  me._stream.on(\"error\", function (e) {\n    me.emit(\"error\", e);\n  });\n\n  me._stream.on(\"data\", function (c) {\n    me._process(c);\n  });\n\n  me._stream.on(\"end\", function () {\n    me._streamEnd();\n  });\n\n  me._stream.on(\"drain\", function () {\n    me.emit(\"drain\");\n  });\n} // overridden in Extract class, since it needs to\n// wait for its DirWriter part to finish before\n// emitting \"end\"\n\n\nParse.prototype._streamEnd = function () {\n  var me = this;\n  if (!me._ended || me._entry) me.error(\"unexpected eof\");\n  me.emit(\"end\");\n}; // a tar reader is actually a filter, not just a readable stream.\n// So, you should pipe a tarball stream into it, and it needs these\n// write/end methods to do that.\n\n\nParse.prototype.write = function (c) {\n  if (this._ended) {\n    // gnutar puts a LOT of nulls at the end.\n    // you can keep writing these things forever.\n    // Just ignore them.\n    for (var i = 0, l = c.length; i > l; i++) {\n      if (c[i] !== 0) return this.error(\"write() after end()\");\n    }\n\n    return;\n  }\n\n  return this._stream.write(c);\n};\n\nParse.prototype.end = function (c) {\n  this._ended = true;\n  return this._stream.end(c);\n}; // don't need to do anything, since we're just\n// proxying the data up from the _stream.\n// Just need to override the parent's \"Not Implemented\"\n// error-thrower.\n\n\nParse.prototype._read = function () {};\n\nParse.prototype._process = function (c) {\n  assert(c && c.length === 512, \"block size should be 512\"); // one of three cases.\n  // 1. A new header\n  // 2. A part of a file/extended header\n  // 3. One of two or more EOF null blocks\n\n  if (this._entry) {\n    var entry = this._entry;\n    if (!entry._abort) entry.write(c);else {\n      entry._remaining -= c.length;\n      if (entry._remaining < 0) entry._remaining = 0;\n    }\n\n    if (entry._remaining === 0) {\n      entry.end();\n      this._entry = null;\n    }\n  } else {\n    // either zeroes or a header\n    var zero = true;\n\n    for (var i = 0; i < 512 && zero; i++) {\n      zero = c[i] === 0;\n    } // eof is *at least* 2 blocks of nulls, and then the end of the\n    // file.  you can put blocks of nulls between entries anywhere,\n    // so appending one tarball to another is technically valid.\n    // ending without the eof null blocks is not allowed, however.\n\n\n    if (zero) {\n      if (this._eofStarted) this._ended = true;\n      this._eofStarted = true;\n    } else {\n      this._eofStarted = false;\n\n      this._startEntry(c);\n    }\n  }\n\n  this.position += 512;\n}; // take a header chunk, start the right kind of entry.\n\n\nParse.prototype._startEntry = function (c) {\n  var header = new TarHeader(c),\n      self = this,\n      entry,\n      ev,\n      EntryType,\n      onend,\n      meta = false;\n\n  if (null === header.size || !header.cksumValid) {\n    var e = new Error(\"invalid tar file\");\n    e.header = header;\n    e.tar_file_offset = this.position;\n    e.tar_block = this.position / 512;\n    return this.emit(\"error\", e);\n  }\n\n  switch (tar.types[header.type]) {\n    case \"File\":\n    case \"OldFile\":\n    case \"Link\":\n    case \"SymbolicLink\":\n    case \"CharacterDevice\":\n    case \"BlockDevice\":\n    case \"Directory\":\n    case \"FIFO\":\n    case \"ContiguousFile\":\n    case \"GNUDumpDir\":\n      // start a file.\n      // pass in any extended headers\n      // These ones consumers are typically most interested in.\n      EntryType = Entry;\n      ev = \"entry\";\n      break;\n\n    case \"GlobalExtendedHeader\":\n      // extended headers that apply to the rest of the tarball\n      EntryType = ExtendedHeader;\n\n      onend = function () {\n        self._global = self._global || {};\n        Object.keys(entry.fields).forEach(function (k) {\n          self._global[k] = entry.fields[k];\n        });\n      };\n\n      ev = \"globalExtendedHeader\";\n      meta = true;\n      break;\n\n    case \"ExtendedHeader\":\n    case \"OldExtendedHeader\":\n      // extended headers that apply to the next entry\n      EntryType = ExtendedHeader;\n\n      onend = function () {\n        self._extended = entry.fields;\n      };\n\n      ev = \"extendedHeader\";\n      meta = true;\n      break;\n\n    case \"NextFileHasLongLinkpath\":\n      // set linkpath=<contents> in extended header\n      EntryType = BufferEntry;\n\n      onend = function () {\n        self._extended = self._extended || {};\n        self._extended.linkpath = entry.body;\n      };\n\n      ev = \"longLinkpath\";\n      meta = true;\n      break;\n\n    case \"NextFileHasLongPath\":\n    case \"OldGnuLongPath\":\n      // set path=<contents> in file-extended header\n      EntryType = BufferEntry;\n\n      onend = function () {\n        self._extended = self._extended || {};\n        self._extended.path = entry.body;\n      };\n\n      ev = \"longPath\";\n      meta = true;\n      break;\n\n    default:\n      // all the rest we skip, but still set the _entry\n      // member, so that we can skip over their data appropriately.\n      // emit an event to say that this is an ignored entry type?\n      EntryType = Entry;\n      ev = \"ignoredEntry\";\n      break;\n  }\n\n  var global, extended;\n\n  if (meta) {\n    global = extended = null;\n  } else {\n    var global = this._global;\n    var extended = this._extended; // extendedHeader only applies to one entry, so once we start\n    // an entry, it's over.\n\n    this._extended = null;\n  }\n\n  entry = new EntryType(header, extended, global);\n  entry.meta = meta; // only proxy data events of normal files.\n\n  if (!meta) {\n    entry.on(\"data\", function (c) {\n      me.emit(\"data\", c);\n    });\n  }\n\n  if (onend) entry.on(\"end\", onend);\n  this._entry = entry;\n\n  if (entry.type === \"Link\") {\n    this._hardLinks[entry.path] = entry;\n  }\n\n  var me = this;\n  entry.on(\"pause\", function () {\n    me.pause();\n  });\n  entry.on(\"resume\", function () {\n    me.resume();\n  });\n\n  if (this.listeners(\"*\").length) {\n    this.emit(\"*\", ev, entry);\n  }\n\n  this.emit(ev, entry); // Zero-byte entry.  End immediately.\n\n  if (entry.props.size === 0) {\n    entry.end();\n    this._entry = null;\n  }\n};","map":{"version":3,"sources":["/Users/samilvaliahmetov/education/programming/schoolProject/my-app/node_modules/node-gyp/node_modules/tar/lib/parse.js"],"names":["module","exports","Parse","create","stream","require","Stream","BlockStream","tar","TarHeader","Entry","BufferEntry","ExtendedHeader","assert","ok","inherits","fstream","Reader","me","apply","writable","readable","_stream","position","_ended","_hardLinks","on","e","emit","c","_process","_streamEnd","prototype","_entry","error","write","i","l","length","end","_read","entry","_abort","_remaining","zero","_eofStarted","_startEntry","header","self","ev","EntryType","onend","meta","size","cksumValid","Error","tar_file_offset","tar_block","types","type","_global","Object","keys","fields","forEach","k","_extended","linkpath","body","path","global","extended","pause","resume","listeners","props"],"mappings":"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","sourcesContent":["\n// A writable stream.\n// It emits \"entry\" events, which provide a readable stream that has\n// header info attached.\n\nmodule.exports = Parse.create = Parse\n\nvar stream = require(\"stream\")\n  , Stream = stream.Stream\n  , BlockStream = require(\"block-stream\")\n  , tar = require(\"../tar.js\")\n  , TarHeader = require(\"./header.js\")\n  , Entry = require(\"./entry.js\")\n  , BufferEntry = require(\"./buffer-entry.js\")\n  , ExtendedHeader = require(\"./extended-header.js\")\n  , assert = require(\"assert\").ok\n  , inherits = require(\"inherits\")\n  , fstream = require(\"fstream\")\n\n// reading a tar is a lot like reading a directory\n// However, we're actually not going to run the ctor,\n// since it does a stat and various other stuff.\n// This inheritance gives us the pause/resume/pipe\n// behavior that is desired.\ninherits(Parse, fstream.Reader)\n\nfunction Parse () {\n  var me = this\n  if (!(me instanceof Parse)) return new Parse()\n\n  // doesn't apply fstream.Reader ctor?\n  // no, becasue we don't want to stat/etc, we just\n  // want to get the entry/add logic from .pipe()\n  Stream.apply(me)\n\n  me.writable = true\n  me.readable = true\n  me._stream = new BlockStream(512)\n  me.position = 0\n  me._ended = false\n  me._hardLinks = {}\n\n  me._stream.on(\"error\", function (e) {\n    me.emit(\"error\", e)\n  })\n\n  me._stream.on(\"data\", function (c) {\n    me._process(c)\n  })\n\n  me._stream.on(\"end\", function () {\n    me._streamEnd()\n  })\n\n  me._stream.on(\"drain\", function () {\n    me.emit(\"drain\")\n  })\n}\n\n// overridden in Extract class, since it needs to\n// wait for its DirWriter part to finish before\n// emitting \"end\"\nParse.prototype._streamEnd = function () {\n  var me = this\n  if (!me._ended || me._entry) me.error(\"unexpected eof\")\n  me.emit(\"end\")\n}\n\n// a tar reader is actually a filter, not just a readable stream.\n// So, you should pipe a tarball stream into it, and it needs these\n// write/end methods to do that.\nParse.prototype.write = function (c) {\n  if (this._ended) {\n    // gnutar puts a LOT of nulls at the end.\n    // you can keep writing these things forever.\n    // Just ignore them.\n    for (var i = 0, l = c.length; i > l; i ++) {\n      if (c[i] !== 0) return this.error(\"write() after end()\")\n    }\n    return\n  }\n  return this._stream.write(c)\n}\n\nParse.prototype.end = function (c) {\n  this._ended = true\n  return this._stream.end(c)\n}\n\n// don't need to do anything, since we're just\n// proxying the data up from the _stream.\n// Just need to override the parent's \"Not Implemented\"\n// error-thrower.\nParse.prototype._read = function () {}\n\nParse.prototype._process = function (c) {\n  assert(c && c.length === 512, \"block size should be 512\")\n\n  // one of three cases.\n  // 1. A new header\n  // 2. A part of a file/extended header\n  // 3. One of two or more EOF null blocks\n\n  if (this._entry) {\n    var entry = this._entry\n    if(!entry._abort) entry.write(c)\n    else {\n      entry._remaining -= c.length\n      if(entry._remaining < 0) entry._remaining = 0\n    }\n    if (entry._remaining === 0) {\n      entry.end()\n      this._entry = null\n    }\n  } else {\n    // either zeroes or a header\n    var zero = true\n    for (var i = 0; i < 512 && zero; i ++) {\n      zero = c[i] === 0\n    }\n\n    // eof is *at least* 2 blocks of nulls, and then the end of the\n    // file.  you can put blocks of nulls between entries anywhere,\n    // so appending one tarball to another is technically valid.\n    // ending without the eof null blocks is not allowed, however.\n    if (zero) {\n      if (this._eofStarted)\n        this._ended = true\n      this._eofStarted = true\n    } else {\n      this._eofStarted = false\n      this._startEntry(c)\n    }\n  }\n\n  this.position += 512\n}\n\n// take a header chunk, start the right kind of entry.\nParse.prototype._startEntry = function (c) {\n  var header = new TarHeader(c)\n    , self = this\n    , entry\n    , ev\n    , EntryType\n    , onend\n    , meta = false\n\n  if (null === header.size || !header.cksumValid) {\n    var e = new Error(\"invalid tar file\")\n    e.header = header\n    e.tar_file_offset = this.position\n    e.tar_block = this.position / 512\n    return this.emit(\"error\", e)\n  }\n\n  switch (tar.types[header.type]) {\n    case \"File\":\n    case \"OldFile\":\n    case \"Link\":\n    case \"SymbolicLink\":\n    case \"CharacterDevice\":\n    case \"BlockDevice\":\n    case \"Directory\":\n    case \"FIFO\":\n    case \"ContiguousFile\":\n    case \"GNUDumpDir\":\n      // start a file.\n      // pass in any extended headers\n      // These ones consumers are typically most interested in.\n      EntryType = Entry\n      ev = \"entry\"\n      break\n\n    case \"GlobalExtendedHeader\":\n      // extended headers that apply to the rest of the tarball\n      EntryType = ExtendedHeader\n      onend = function () {\n        self._global = self._global || {}\n        Object.keys(entry.fields).forEach(function (k) {\n          self._global[k] = entry.fields[k]\n        })\n      }\n      ev = \"globalExtendedHeader\"\n      meta = true\n      break\n\n    case \"ExtendedHeader\":\n    case \"OldExtendedHeader\":\n      // extended headers that apply to the next entry\n      EntryType = ExtendedHeader\n      onend = function () {\n        self._extended = entry.fields\n      }\n      ev = \"extendedHeader\"\n      meta = true\n      break\n\n    case \"NextFileHasLongLinkpath\":\n      // set linkpath=<contents> in extended header\n      EntryType = BufferEntry\n      onend = function () {\n        self._extended = self._extended || {}\n        self._extended.linkpath = entry.body\n      }\n      ev = \"longLinkpath\"\n      meta = true\n      break\n\n    case \"NextFileHasLongPath\":\n    case \"OldGnuLongPath\":\n      // set path=<contents> in file-extended header\n      EntryType = BufferEntry\n      onend = function () {\n        self._extended = self._extended || {}\n        self._extended.path = entry.body\n      }\n      ev = \"longPath\"\n      meta = true\n      break\n\n    default:\n      // all the rest we skip, but still set the _entry\n      // member, so that we can skip over their data appropriately.\n      // emit an event to say that this is an ignored entry type?\n      EntryType = Entry\n      ev = \"ignoredEntry\"\n      break\n  }\n\n  var global, extended\n  if (meta) {\n    global = extended = null\n  } else {\n    var global = this._global\n    var extended = this._extended\n\n    // extendedHeader only applies to one entry, so once we start\n    // an entry, it's over.\n    this._extended = null\n  }\n  entry = new EntryType(header, extended, global)\n  entry.meta = meta\n\n  // only proxy data events of normal files.\n  if (!meta) {\n    entry.on(\"data\", function (c) {\n      me.emit(\"data\", c)\n    })\n  }\n\n  if (onend) entry.on(\"end\", onend)\n\n  this._entry = entry\n\n  if (entry.type === \"Link\") {\n    this._hardLinks[entry.path] = entry\n  }\n\n  var me = this\n\n  entry.on(\"pause\", function () {\n    me.pause()\n  })\n\n  entry.on(\"resume\", function () {\n    me.resume()\n  })\n\n  if (this.listeners(\"*\").length) {\n    this.emit(\"*\", ev, entry)\n  }\n\n  this.emit(ev, entry)\n\n  // Zero-byte entry.  End immediately.\n  if (entry.props.size === 0) {\n    entry.end()\n    this._entry = null\n  }\n}\n"]},"metadata":{},"sourceType":"script"}